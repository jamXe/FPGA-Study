// Generated by FFT 13.1 [Altera, IP Toolbench 1.3.0 Build 162]
// ************************************************************
// THIS IS A WIZARD-GENERATED FILE. DO NOT EDIT THIS FILE!
// ************************************************************
// Copyright (C) 1991-2015 Altera Corporation
// Any megafunction design, and related net list (encrypted or decrypted),
// support information, device programming or simulation file, and any other
// associated documentation or information provided by Altera or a partner
// under Altera's Megafunction Partnership Program may be used only to
// program PLD devices (but not masked PLD devices) from Altera.  Any other
// use of such megafunction design, net list, support information, device
// programming or simulation file, or any other related documentation or
// information is prohibited for any other purpose, including, but not
// limited to modification, reverse engineering, de-compiling, or use with
// any other silicon devices, unless such use is explicitly licensed under
// a separate agreement with Altera or a megafunction partner.  Title to
// the intellectual property, including patents, copyrights, trademarks,
// trade secrets, or maskworks, embodied in any such megafunction design,
// net list, support information, device programming or simulation file, or
// any other related documentation or information provided by Altera or a
// megafunction partner, remains with Altera, the megafunction partner, or
// their respective licensors.  No other licenses, including any licenses
// needed under any third party's intellectual property, are provided herein.

module FFT_Control_Module
(
	//输入端口
	CLK_50M,RST_N,data_real_in_int,
	//输出端口
	fft_real_out_int,fft_imag_out_int,fft_bit_cnt,vga_freq,vga_fengzhi,vga_pingjunzhi
);

//---------------------------------------------------------------------------
//--	外部端口声明
//---------------------------------------------------------------------------
input					CLK_50M;
input					RST_N;
input 	[ 9:0]	data_real_in_int;
output 	[31:0] 	vga_freq;
output 	[31:0] 	vga_fengzhi;
output 	[ 9:0] 	vga_pingjunzhi;
output   [ 9:0] 	fft_bit_cnt;
output  	[ 9:0] 	fft_real_out_int;
output  	[ 9:0] 	fft_imag_out_int;

//---------------------------------------------------------------------------
//--	内部端口声明
//---------------------------------------------------------------------------
wire					sink_sop;
wire					sink_eop;
wire					inverse;
wire		[ 1:0]	sink_error;
wire					source_ready;
wire					sink_ready;
wire		[ 1:0]	source_error;
wire					source_sop;
wire					source_eop;
wire					source_valid;
wire		[ 5:0]	source_exp;
wire	 	[ 9:0]	source_real;
wire	 	[ 9:0]	source_imag;
reg					fft_start;
reg					fft_start_n;
wire 					end_input;
wire 					end_output;
reg		[ 9:0]	fft_bit_cnt;
reg		[ 9:0]	fft_bit_cnt_n;
reg		[ 9:0]	sink_real;
reg		[ 9:0]	sink_real_n;
reg		[ 9:0]	sink_imag;
reg		[ 9:0]	sink_imag_n;
reg					sink_valid;
reg					sink_valid_n;
reg 		[ 9:0] 	fft_real_out_int;
reg 		[ 9:0] 	fft_real_out_int_n;
reg 		[ 9:0]	fft_imag_out_int;
reg 		[ 9:0] 	fft_imag_out_int_n;
reg 		[ 5:0]	exponent_out_int;	
reg 		[ 5:0]	exponent_out_int_n;
reg 		[31:0] 	fft_real_image_data;
reg 		[31:0] 	fft_real_image_data_n;
wire		[15:0] 	sqrt_data_out;
reg 		[ 9:0] 	data_max;
reg 		[ 9:0] 	data_max_n;
reg 		[ 9:0] 	data_max2;
reg 		[ 9:0] 	data_max2_n;
reg 		[ 9:0] 	max_cnt;
reg 		[ 9:0] 	max_cnt_n;
reg 		[ 9:0] 	max_cnt2;
reg 		[ 9:0] 	max_cnt2_n;
reg 		[15:0] 	fengzhi_max;
reg 		[15:0] 	fengzhi_max_n;
reg 		[15:0] 	fengzhi_min;
reg 		[15:0] 	fengzhi_min_n;
reg 		[ 9:0] 	data_imag_in_int = 10'b0;
reg 		[ 9:0] 	fftpts_array = 255;

//---------------------------------------------------------------------------
//--	逻辑功能实现	
//---------------------------------------------------------------------------
// Set FFT Direction '0' => FFT '1' => IFFT
assign inverse = 1'b0;

//no input error
assign sink_error = 2'b0;

// for example purposes, the ready signal is always asserted.
assign source_ready = 1'b1;

// sink_valid == 1'b1 && sink_ready == 1'b1
assign fft_ready_valid = (sink_valid && sink_ready);

// start valid for first cycle to indicate that the file reading should start.
always @ (posedge CLK_50M or negedge RST_N)
begin
	if(!RST_N)
		fft_start <= 1'b1;
	else
		fft_start <= fft_start_n;
end

always @ (*)
begin
	if(fft_ready_valid)
		fft_start_n = 1'b0;
	else
		fft_start_n = 1'b1;
end

//sop and eop asserted in first and last sample of data
always @ (posedge CLK_50M or negedge RST_N)
begin
	if(!RST_N)
		fft_bit_cnt <= 10'b0;
	else
		fft_bit_cnt <= fft_bit_cnt_n;
end

always @ (*)
begin
	if(fft_ready_valid && (fft_bit_cnt == fftpts_array))
		fft_bit_cnt_n = 1'b0;		
	else if(fft_ready_valid)
		fft_bit_cnt_n = fft_bit_cnt + 1'b1;
	else
		fft_bit_cnt_n = fft_bit_cnt;
end

// signal when all of the output data has be received from the DUT
assign end_output = (source_eop && source_valid && source_ready) ? 1'b1 : 1'b0;
	
// signal when all of the input data has been sent to the DUT
assign end_input = (sink_eop && sink_valid && sink_ready) ? 1'b1 : 1'b0;
    
// generate start and end of packet signals
assign sink_sop = (fft_bit_cnt == 1'b0) ? 1'b1 : 1'b0 ;
assign sink_eop = (fft_bit_cnt == fftpts_array) ? 1'b1 : 1'b0;
       
reg	end_test;
reg	end_test_n;

// halt the input when done
always @ (posedge CLK_50M or negedge RST_N)
begin
	if(!RST_N)
		end_test <= 1'b0;
	else
		end_test <= end_test_n;
end

always @ (*)
begin
	if(end_input)
		end_test_n = 1'b1;
	else
		end_test_n = end_test;
end

// Read input data from files. Data is generated on the negative edge of the clock, CLK_50M, in the
// testbench and registered by the core on the positive edge of the clock 
always @ (posedge CLK_50M or negedge RST_N)
begin
	if(!RST_N)
		sink_real <= 10'b0;
	else
		sink_real <= sink_real_n;
end

always @ (*)
begin
	if(end_test || end_input)
		sink_real_n = 10'b0;
	else if (fft_ready_valid || (fft_start & !(sink_valid && sink_ready == 1'b0)))
		sink_real_n = data_real_in_int;
	else
		sink_real_n = sink_real;
end

always @ (posedge CLK_50M or negedge RST_N)
begin
	if(!RST_N)
		sink_imag <= 10'b0;
	else
		sink_imag <= sink_imag_n;
end

always @ (*)
begin
	if(end_test || end_input)
		sink_imag_n = 10'b0;
	else if (fft_ready_valid || (fft_start & !(sink_valid && sink_ready == 1'b0)))
		sink_imag_n = data_imag_in_int;
	else
		sink_imag_n = sink_imag;
end


always @ (posedge CLK_50M or negedge RST_N)
begin
	if(!RST_N)
		sink_valid <= 1'b0;
	else
		sink_valid <= sink_valid_n;
end

always @ (*)
begin
	if(end_test || end_input)
		sink_valid_n = 1'b0;
	else if (fft_ready_valid || (fft_start & !(sink_valid && sink_ready == 1'b0)))
		sink_valid_n = 1'b1;
	else
		sink_valid_n = 1'b1;
end

always @ (posedge CLK_50M or negedge RST_N)
begin
	if(!RST_N)
		fft_real_out_int <= 10'b0;
	else
		fft_real_out_int <= fft_real_out_int_n;
end

always @ (*)
begin
	if(source_valid && source_ready)
		fft_real_out_int_n = source_real[9] ? (~source_real[9:0]+1) : source_real;
	else
		fft_real_out_int_n = fft_real_out_int; 
end

always @ (posedge CLK_50M or negedge RST_N)
begin
	if(!RST_N)
		fft_imag_out_int <= 10'b0;
	else
		fft_imag_out_int <= fft_imag_out_int_n;
end

always @ (*)
begin
	if(source_valid && source_ready)
		fft_imag_out_int_n = source_imag[9] ? (~source_imag[9:0]+1) : source_imag;
	else
		fft_imag_out_int_n = fft_imag_out_int;
end

always @ (posedge CLK_50M or negedge RST_N)
begin
	if(!RST_N)
		exponent_out_int <= 10'b0;
	else
		exponent_out_int <= exponent_out_int_n;
end

always @ (*)
begin
	if(source_valid && source_ready)
		exponent_out_int_n = source_exp;
	else
		exponent_out_int_n = exponent_out_int;
end


always @ (posedge CLK_50M or negedge RST_N)
begin
	if(!RST_N)
		fft_real_image_data <= 32'b0;
	else
		fft_real_image_data <= fft_real_image_data_n;
end

always @ (*)
begin
	if(source_valid && source_ready)
		fft_real_image_data_n = fft_real_out_int*fft_real_out_int + fft_imag_out_int*fft_imag_out_int;
	else
		fft_real_image_data_n = fft_real_image_data;
end

SQRT_Module		SQRT_Init 
(
	.radical 	(fft_real_image_data ),
	.q 			(sqrt_data_out 		)
);

always @ (posedge CLK_50M or negedge RST_N)
begin
	if(!RST_N)
		data_max <= 10'b0;
	else
		data_max <= data_max_n;
end

always @ (*)
begin
	if(sqrt_data_out > data_max)
		data_max_n = sqrt_data_out;
	else
		data_max_n = data_max;
end

always @ (posedge CLK_50M or negedge RST_N)
begin
	if(!RST_N)
		data_max2 <= 10'b0;
	else
		data_max2 <= data_max2_n;
end

always @ (*)
begin
	if(sqrt_data_out > data_max)
		data_max2_n = data_max2;
	else if((sqrt_data_out > data_max2) && (sqrt_data_out != data_max))
		data_max2_n = sqrt_data_out;
	else
		data_max2_n = data_max2;
end

always @ (posedge CLK_50M or negedge RST_N)
begin
	if(!RST_N)
		max_cnt <= 10'b0;
	else
		max_cnt <= max_cnt_n;
end

always @ (*)
begin
	if(sqrt_data_out > data_max)
		max_cnt_n = max_cnt;
	else if((sqrt_data_out > data_max2) && (sqrt_data_out != data_max))
		max_cnt_n = max_cnt2 - 10'd23;
	else
		max_cnt_n = max_cnt;
end

always @ (posedge CLK_50M or negedge RST_N)
begin
	if(!RST_N)
		max_cnt2 <= 10'b0;
	else
		max_cnt2 <= max_cnt2_n;
end

always @ (*)
begin
	if(sqrt_data_out > data_max)
		max_cnt2_n = max_cnt2 + 1'b1;
	else if((sqrt_data_out > data_max2) && (sqrt_data_out != data_max))
		max_cnt2_n = max_cnt2 + 1'b1;
	else if(max_cnt2 >= 10'd256)
		max_cnt2_n = 10'b0;
	else
		max_cnt2_n = max_cnt2 + 1'b1;;
end

always @ (posedge CLK_50M or negedge RST_N)
begin
	if(!RST_N)
		fengzhi_max <= 16'b0;
	else
		fengzhi_max <= fengzhi_max_n;
end

always @ (*)
begin
	if(data_real_in_int > fengzhi_max)
		fengzhi_max_n = data_real_in_int;
	else
		fengzhi_max_n = fengzhi_max;
end

always @ (posedge CLK_50M or negedge RST_N)
begin
	if(!RST_N)
		fengzhi_min <= 16'd255;
	else
		fengzhi_min <= fengzhi_min_n;
end

always @ (*)
begin
	if(fengzhi_min > data_real_in_int)
		fengzhi_min_n = data_real_in_int;
	else
		fengzhi_min_n = fengzhi_min;
end

assign vga_freq = (max_cnt) * 32'd42667 >> 8'd8;
assign vga_fengzhi = ((fengzhi_max - fengzhi_min) * 10'd50) >> 8'd8; //((data_max3 * 10'd100) >> 8'd8) + 10'd2;  
		
fft fft_init
(
	.clk					(CLK_50M			),
	.reset_n				(RST_N			),
	.inverse				(inverse			),
	.sink_valid			(sink_valid		),
	.sink_sop			(sink_sop		),	
	.sink_eop			(sink_eop		),
	.sink_real			(sink_real		),
	.sink_imag			(sink_imag		),
	.sink_error			(sink_error		),
	.source_ready		(source_ready	),
	.sink_ready			(sink_ready		),
	.source_error		(source_error	),
	.source_sop			(source_sop		),
	.source_eop			(source_eop		),
	.source_valid		(source_valid	),
	.source_exp			(source_exp		),
	.source_real		(source_real	),
	.source_imag		(source_imag	)
);


endmodule
